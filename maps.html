<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
        <title>Google Maps API (v3): polyline from directions</title>
        <script type="text/javascript" src="https://www.google.com/jsapi"></script>
        <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
        <style type="text/css">
		  #legend {
		    background: white;
		    padding: 10px;
		  }
		</style>

        <script type="text/javascript">
        var map;
        var directionsService;
        var request;
        var geocoder;
        var data;

        function initialize() {
            var center = new google.maps.LatLng(52.229676, 21.012229);
            geocoder = new google.maps.Geocoder();
            directionsService = new google.maps.DirectionsService(); 
              map = new google.maps.Map(document.getElementById('map_canvas'), {
                center: center,
                zoom: 13,
                mapTypeId: google.maps.MapTypeId.ROADMAP
            });
            data = new google.visualization.DataTable();
            data.addColumn('string', 'interval');
            data.addColumn('number', 'Excitement value');

        }
        function getColour(value){
            var outcolor = '#000000'; //White
            if (value >= 30){
                outcolor = '#FF0000'; //Blue
            }else if(value >= 10){
                outcolor = '#0000FF'; //Blue
            }else{
                outcolor = '#00FF00'; //Green
            }   
            return outcolor;   	
        }

        function evaluatePath() {
            var myLatlng = 0;
            var markers = [];
            var contentStrings = [];
            var infowindows = [];
            var totExcitement = [];
            var chart;


            ///geocoding input//
            var pStart = document.getElementById('address0').value;
            var pEnd = document.getElementById('address1').value;
            var alg = document.getElementById('algorythm').value;

            var directionsService = new google.maps.DirectionsService();
            var request = {
                origin: pStart,
                destination: pEnd,
                travelMode: google.maps.DirectionsTravelMode.DRIVING
            };
            var polyline = []; 
	        polyline[0]= new google.maps.Polyline({
		        path: [],
		        strokeColor: '#00FF00',
		        strokeWeight: 3,
		        map: map
            });
                                   
            directionsService.route(request, function(result, status) {
                if (status == google.maps.DirectionsStatus.OK) {
                    var bounds = new google.maps.LatLngBounds();
                    var path = result.routes[0].overview_path;
                    var legs = result.routes[0].legs;
                    myLatlng = elaborateRoute(map, legs,polyline,
                        bounds, markers,
                        contentStrings, totExcitement, alg);
                    //assign colors to polyline//
                    setMultplePolylineColor(polyline, totExcitement);
                    //calculate average excitement//
                    var ExMark =0;
                    for(i=0;i<totExcitement.length;i++){
                        ExMark += totExcitement[i];
                    }
                    ExMark/= totExcitement.length; 
                    map.fitBounds(bounds);
                    ////legend//
                    var legend = document.createElement('div');
                    legend.id = 'legend';
                    var content = [];
                    for(i=0;i<30/*headingArray.length*/;i++){
                        content.push('<p><div class="legend"></div>H'+i+'='+totExcitement[i]+'</p>');
                        data.addRow(['T'+i, totExcitement[i]]);
                        //window.alert("Table Add row= "+data.getValue((data.getNumberOfRows()-1), 2));
                    }
                    legend.innerHTML = content.join('');
                    legend.index = 1;
                    map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(legend);
      
                    //inject the final marker
                    var markerImage = new
                        google.maps.MarkerImage('destIcon.png',
                                new google.maps.Size(50, 51), null,
                                new google.maps.Point(50, 50));
                    markers[markers.length]= new google.maps.Marker({
                            position: myLatlng,
                            map: map,
                            title: 'destination',
                            icon: markerImage
                        });

                   // polyline.setMap(map);
                    for (i=0;i<markers.length;i++) {
                      infowindows[i] = new google.maps.InfoWindow({
                          content: contentStrings[i]
                      });
                      google.maps.event.addListener(markers[i], 'click', (function(i) {
                        return function(){
                          infowindows[i].open(map,markers[i]);
                        }
                      })(i));

                    }

                    //window.alert("Table rows= "+data.getNumberOfRows());
                    drawChart();
                }
            });
        }
        //function to elaborate the route received//
        // in: map, legs, polyline, bounds, algorythm
        // out: markers, contentStrings
        // return value = final position

        function elaborateRoute(map, legs, polyline, bounds,  markers,
                contentStrings, totExcitement, alg){
            if(alg==0) return elaborateDH(map, legs, polyline, bounds,
                    markers, contentStrings, totExcitement);
            else if(alg==1) return elaborateNumSections(map, legs,
                    polyline, bounds,  markers, contentStrings, totExcitement);
            else if(alg==2) return elaborateBbyB(map, legs,
                    polyline, bounds,  markers, contentStrings, totExcitement);

        }
        function elaborateDH(map, legs, polyline, bounds,  markers, contentStrings, totExcitement){
            var TotsegLength =0;
            var HeadVar =0;
            var p = 0;
            var prevHeading =256;
            var heading = 0;
            var headingArray = [];
            var prevSegment = 0;	
            var bendsNumSeg = 0;
            var bendDirection =0;
            var bendDetection =0;
            var exitLength = 50; //max lenght without variation of heading
            var bendLengths = [];
            var bendHeadBuffer= [];
            var bendDHead= [];
            var bendLengthBuffer= [];
            var myPosition =0;
            var bendLength =0;
            var bendDirection=0;

            //debug vars//
            var totLegs = legs.length;
            var totSteps =0;
            var totSegs =0;
            var headingTemp =0

            for (i=0;i<legs.length;i++) {
                var steps = legs[i].steps;
                totSteps += steps.length;
                for (j=0;j<steps.length;j++) {
                    var nextSegment = steps[j].path;
                    totSegs +=nextSegment.length;
                    for (k=0;k<nextSegment.length;k++) {
                        var segLength =0;
                        if(!((k==0)&&(i==0)&&(j==0))) { 
                            heading = google.maps.geometry.spherical.computeHeading(prevSegment, nextSegment[k]);
                            if(prevHeading!=256){
                                var tempHead = heading-prevHeading;
                                if(!tempHead) tempHead = 0;
                                if(tempHead > 180) tempHead = 360-HeadVar;
                                if(tempHead < -180) tempHead =
                                    -360-HeadVar; //negative angle keep direction of turning
                                HeadVar += tempHead;
                                headingTemp=tempHead;
                                segLength = google.maps.geometry.spherical.computeDistanceBetween(prevSegment, nextSegment[k]);
                                if((Math.abs(tempHead/segLength) > 0.3) && (exitLength >= 0)){
                                    bendHeadBuffer[bendHeadBuffer.length] = tempHead; //this is for future calcs
                                    bendLengthBuffer[bendLengthBuffer.length] = segLength;
                                    headingArray[headingArray.length] = 100; //trick for the color meaning in bend
                                    if(bendDetection==0) {
                                        bendDetection=1;
                                        if(tempHead>=0) bendDirection=1;
                                        else bendDirection=-1; ///set the direction of the bend
                                        //window.alert("Bend start, perc="+(tempHead/segLength));
                                    }else{ 
                                        //window.alert("Bend Continue, perc="+(tempHead/segLength));
                                        if(((tempHead>=0)&&(bendDirection==1))||((tempHead<=0)&&(bendDirection==-1)))
                                        {  
                                            ///all good bend continues
                                            exitLength=50;
                                        }
                                        else {
                                            ///end of this bend///
                                            exitLength-=segLength;
                                        } 
                                    }
                                }else{
                                    if(bendDetection==1){ 
                                        if(exitLength >= 0){
                                            exitLength -= segLength;
                                            bendHeadBuffer[bendHeadBuffer.length] = tempHead; //this is for future calcs
                                            bendLengthBuffer[bendLengthBuffer.length] = segLength;
                                            headingArray[headingArray.length] = 100; //trick for the color
                                           // window.alert("Bend Continue, exit="+exitBend);
                                        }else{
                                            //end of Bend
                                            bendDetection =0;
                                            bendDirection =0;//reset bend direction
                                            var totDHead = 0;
                                            window.alert("Exiting the bend n"+bendLengths.length+" exit length "+exitLength);
                                            for(s=0; s<bendLengthBuffer.length; s++){
                                                bendLength += bendLengthBuffer[s];
                                                totDHead += bendHeadBuffer[s];
                                            }
                                            bendLengths[bendLengths.length] = bendLength;
                                            bendDHead[bendDHead.length]= totDHead;
                                            bendLength=0;
                                            bendsNumSeg++; //increment the number of detected bends in this segment
                                            //window.alert("Bend Detected, lenght="+bendLengths[bendLengths.length-1]);
                                            
                                            //clear bendBuffers scary javascript
                                            bendHeadBuffer = [];
                                            bendLengthBuffer = [];
                                            exitLength = 50;
                                            headingArray[headingArray.length]= 0;
                                        }
                                    }else  headingArray[headingArray.length]= 0;
                                }
                            } 
                            prevHeading = heading;
                        } 
                        TotsegLength+=segLength;
                        prevSegment = nextSegment[k];
                        polyline[p].getPath().push(nextSegment[k]);
                        bounds.extend(nextSegment[k]);
                        myPosition = nextSegment[k];
                        //headingArray[headingArray.length] = heading;
               
                       /* if(TotsegLength>=2000){
                            markers[p] = new google.maps.Marker({
                              position: myPosition,
                              map: map,
                              title: 'T'+p
                            });
                            totExcitement[p]= (bendsNumSeg/TotsegLength)
                                *37500;
                            contentStrings[p] = '<div id="content">'+'T'+p+' TotLenght ='+TotsegLength.toFixed(2)+'Number of bends'+bendsNumSeg+'</div>';
                           
                            for(z=0;z < bendDHead.length; z++)
                            {
                                window.alert("Bend n="+z+" DHead="+bendDHead[z].toFixed(2)+" Length="+bendLengths[z]);
                            }
                            p++;
                            HeadVar = 0; //reset counters and statistics
                            TotsegLength = 0;
                            bendsNumSeg = 0;
                            bendDHead = [];
                            bendLengths = [];
                            ///create a new polyline////
                            polyline[p]= new google.maps.Polyline({
                            path: [],
                            strokeColor: '#00FF00',
                            strokeWeight: 3,
                            map: map
                            });
                            polyline[p].getPath().push(nextSegment[k]);
                            //init new polyline where the previous ended.
                        }*/
                            markers[p] = new google.maps.Marker({
                              position: myPosition,
                              map: map,
                              title: 'T'+p
                            });
                            if(headingArray.length > 1) totExcitement[p]= headingArray[headingArray.length-1];
                            else totExcitement[p] = 0;
                            contentStrings[p] = '<div id="content">'+' Segment '+k+'lenght ='+segLength+' VarHeading = '+headingTemp+'</div>';
                           
                            p++;
                            HeadVar = 0; //reset counters
                            TotsegLength = 0;
                            ///create a new polyline////
                            polyline[p]= new google.maps.Polyline({
                            path: [],
                            strokeColor: '#00FF00',
                            strokeWeight: 3,
                            map: map
                            });
                            polyline[p].getPath().push(nextSegment[k]);
                            //init new polyline where the previous ended.
                            

                    }
                }
            }

            window.alert("Bends Detected="+bendLengths.length);
            window.alert("legs= "+totLegs+"steps= "+totSteps+"segments="+totSegs);
            return myPosition;
        }

        function elaborateBbyB(map, legs, polyline, bounds,  markers, contentStrings, totExcitement){
            var TotsegLength =0;
            var HeadVar =0;
            var p = 0;
            var prevHeading =256;
            var heading = 0;
            var headingArray = [];
            var prevSegment = 0;	
            var bendsNumSeg = 0;
            var bendDirection =0;
            var bendDetection =0;
            var exitMacroLength = 40;
            var minBendRatio = 3;
            var exitLength = exitMacroLength; //max lenght without variation of heading
            var bendLengths = [];
            var bendHeadBuffer= [];
            var bendDHead= [];
            var bendLengthBuffer= [];
            var myPosition =0;
            var bendLength =0;
            var bendDirection=0;
            var misDirectionFlag=0;

            //debug vars//
            var totLegs = legs.length;
            var totSteps =0;
            var totSegs =0;
            
           /* polyline[polyline.length]= new google.maps.Polyline({
                path: [],
                strokeColor: '#00FF00',
                strokeWeight: 3,
                map: map
            });
            */
            totExcitement[totExcitement.length] = 0;
        
            var myWindow = window.open("", "MsgWindow", "width=1000, height=1000");

            var segLength =0;
            for (i=0;i<legs.length;i++) {
                var steps = legs[i].steps;
                for (j=0;j<steps.length;j++) {
                    var nextSegment = steps[j].path;
                    for (k=0;k<nextSegment.length;k++) {
                        if(!((k==0)&&(i==0)&&(j==0))) { 
                            heading = google.maps.geometry.spherical.computeHeading(prevSegment, nextSegment[k]);
                            if(prevHeading!=256){
                                var tempHead = heading-prevHeading;
                                if(!tempHead) tempHead = 0;
                                if(tempHead > 180) tempHead = 360-HeadVar;
                                if(tempHead < -180) tempHead =
                                    -360-HeadVar; //negative angle keep direction of turning
                                HeadVar += tempHead;
                                segLength = google.maps.geometry.spherical.computeDistanceBetween(prevSegment, nextSegment[k]);
                                myWindow.document.write("<p> Segment = "+k+" DHead = "+(tempHead)+"Length="+segLength+"</p>");
                                totSegs++;
                                if((Math.abs(tempHead) >= minBendRatio) && (exitLength >= 0)){
                                    bendHeadBuffer[bendHeadBuffer.length] = tempHead; //this is for future calcs
                                    bendLengthBuffer[bendLengthBuffer.length] = segLength;
                                    headingArray[headingArray.length] = 100; //trick for the color meaning in bend
                                    if(bendDetection==0) {
                                        bendDetection=1;
                                        exitLength = exitMacroLength;

                                        myWindow.document.write("<p> Start of new bend segn= "+k+"</p>");
                                        if(tempHead>=0) bendDirection=1;
                                        else bendDirection=-1; ///set the direction of the bend
                                        ///create a new polyline////
                                        polyline[polyline.length-1].getPath().push(nextSegment[k]);
                                       // p++;
                                        //totExcitement[totExcitement.length] = 0;
                                        polyline[polyline.length]= new google.maps.Polyline({
                                        path: [],
                                        strokeColor: '#00FF00',
                                        strokeWeight: 3,
                                        map: map
                                        });

                                        totExcitement[totExcitement.length] = 0;
                                        markers[markers.length] = new google.maps.Marker({
                                        position: nextSegment[k],
                                             map: map,
                                            title: 'T'+(markers.lenght-1)
                                        });
                                        contentStrings[contentStrings.length] = '<div id="content">'+'No bends'+'Nsegs='+totSegs+'</div>';
                                        TotsegLength = 0;
                                        totSegs = 0;
                                        HeadVar = 0; //reset counters

                                       // polyline[p].getPath().push(nextSegment[k]);
                                        //window.alert("Bend start, perc="+(tempHead/segLength));
                                    }else{ 
                                        //window.alert("Bend Continue, perc="+(tempHead/segLength));
                                        if(((tempHead>=0)&&(bendDirection==1))||((tempHead<0)&&(bendDirection==-1)))
                                        {  
                                            ///all good bend continues
                                            exitLength = exitMacroLength;
                                        }
                                        else {
                                            ///end of this bend///
                                            exitLength-=segLength;
                                            myWindow.document.write("<p> Change of Direction in Bend remaining space= "+exitLength+" subtracted= "+segLength+"</p>");
                                            ///we need to set a flag and before exiting evaluate if we considered the sign wrong.
                                            misDirectionFlag=1;
                                            //window.alert("Change of Direction in Bend remaining space= "+exitLength+" subtracted= "+segLength);
                                        } 
                                    }
                                }else{
                                    if(bendDetection==1){ 
                                        if(exitLength >= 0){
                                            exitLength -= segLength;
                                            //window.alert("Straight tract exit Rem= "+exitLength+" subtracted= "+segLength);
                                            myWindow.document.write("<p> Straight tract exit Rem= "+exitLength+" subtracted= "+segLength+"</p>");
                                            bendHeadBuffer[bendHeadBuffer.length] = tempHead; //this is for future calcs
                                            bendLengthBuffer[bendLengthBuffer.length] = segLength;
                                            headingArray[headingArray.length] = 100; //trick for the color
                                           // window.alert("Bend Continue, exit="+exitBend);
                                        }else{
                                            var end_of_bend=1;
                                            if(misDirectionFlag)
                                            {
                                                misDirectionFlag =0;
                                                var sum_direction=0;
                                                for(z=0; z<bendHeadBuffer.length; z++)
                                                {
                                                    sum_direction += bendHeadBuffer[z];
                                                }
                                                if(((sum_direction >= 0) && (bendDirection < 0))||((sum_direction < 0)&&(bendDirection > 0))) 
                                                {
                                                    if(sum_direction >=0) bendDirection = 1;
                                                    else bendDirection= -1;
                                                    myWindow.document.write("<p> Mis-direction seg_no= "+k+"</p>");
                                                    bendHeadBuffer[bendHeadBuffer.length] = tempHead; //this is for future calcs
                                                    bendLengthBuffer[bendLengthBuffer.length] = segLength;
                                                    headingArray[headingArray.length] = 100; //trick for the color
                                                    end_of_bend=0;
                                                    exitLength = exitMacroLength;
                                                }
                                            }
                                            if(end_of_bend)
                                            {
                                                //end of Bend

                                                bendDetection =0;
                                                bendDirection =0;//reset bend direction
                                                var totDHead = 0;
                                                for(s=0; s<bendLengthBuffer.length; s++){
                                                    bendLength += bendLengthBuffer[s];
                                                    totDHead += bendHeadBuffer[s];
                                                }
                                                bendLengths[bendLengths.length] = bendLength;
                                                bendDHead[bendDHead.length]= totDHead;
                                                bendLength=0;
                                                bendsNumSeg++; //increment the number of detected bends in this segment
                                                //window.alert("Bend Detected, lenght="+bendLengths[bendLengths.length-1]);
                                                 myWindow.document.write("<p> End Of Bend segNo= "+k+"</p>");

                                                //clear bendBuffers scary javascript
                                                bendHeadBuffer = [];
                                                bendLengthBuffer = [];
                                                exitLength = exitMacroLength;
                                                headingArray[headingArray.length]= 0;
                                                markers[markers.length] = new google.maps.Marker({
                                                  position: nextSegment[k],
                                                  map: map,
                                                  title: 'T'+(markers.lenght-1)
                                                });
                                                totExcitement[totExcitement.length-1] = (Math.abs(bendDHead[bendDHead.length-1])/bendLengths[bendLengths.length-1]) * 100 ;
                                                contentStrings[contentStrings.length] = '<div id="content">'+'bend='+(markers.length-1)+' Length='+bendLengths[bendLengths.length-1]+' Var Ang='+bendDHead[bendDHead.length-1]+'Nsegs='+totSegs+'</div>';
                                                polyline[polyline.length-1].getPath().push(nextSegment[k]);
                                               // p++;
                                                HeadVar = 0; //reset counters
                                                TotsegLength = 0;
                                                totSegs = 0;
                                                polyline[polyline.length]= new google.maps.Polyline({
                                                    path: [],
                                                    strokeColor: '#00FF00',
                                                    strokeWeight: 3,
                                                    map: map
                                                });
                                                totExcitement[totExcitement.length] = 0;
                                                //initialize total excitement
                                            }
                                        }
                                    }else{
                                        //boring part no bends

                                            myWindow.document.write("<p> No bends No detect seg No= "+k+"</p>");
                                        
                                    }

                                }
                            } 
                            prevHeading = heading;
                        } 
                        TotsegLength+=segLength;
                        prevSegment = nextSegment[k];
                        polyline[polyline.length-1].getPath().push(nextSegment[k]);
                        bounds.extend(nextSegment[k]);
                        myPosition = nextSegment[k];
                        //window.alert("Seg = "+k+"Heading= "+heading);
                        //headingArray[headingArray.length] = heading;
               
                       /* if(TotsegLength>=2000){
                            markers[p] = new google.maps.Marker({
                              position: myPosition,
                              map: map,
                              title: 'T'+p
                            });
                            totExcitement[p]= (bendsNumSeg/TotsegLength)
                                *37500;
                            contentStrings[p] = '<div id="content">'+'T'+p+' TotLenght ='+TotsegLength.toFixed(2)+'Number of bends'+bendsNumSeg+'</div>';
                           
                            for(z=0;z < bendDHead.length; z++)
                            {
                                window.alert("Bend n="+z+" DHead="+bendDHead[z].toFixed(2)+" Length="+bendLengths[z]);
                            }
                            p++;
                            HeadVar = 0; //reset counters and statistics
                            TotsegLength = 0;
                            bendsNumSeg = 0;
                            bendDHead = [];
                            bendLengths = [];
                            ///create a new polyline////
                            polyline[p]= new google.maps.Polyline({
                            path: [],
                            strokeColor: '#00FF00',
                            strokeWeight: 3,
                            map: map
                            });
                            polyline[p].getPath().push(nextSegment[k]);
                            //init new polyline where the previous ended.
                        }*/
                                                       //init new polyline where the previous ended.
                            

                    }
                }
            }

            window.alert("Bends Detected="+bendLengths.length);
           // window.alert("legs= "+totLegs+"steps= "+totSteps+"segments="+totSegs);
            return myPosition;
        }
        //function to assign different colors to each part of the
        //polyline
        // in : polyline
        // totExcitement: Values correpondent to each segment of
        // polyline
        
        function setMultplePolylineColor(polyline, totExcitement){
            for(i=0; i<polyline.length; i++){
                ////set colour vaue in previous polyline///
                var colour = getColour(totExcitement[i]);
                //alert('This is the new color='+colour);
                polyline[i].setOptions({strokeColor: colour});
            }
        }
        function elaborateNumSections(map, legs, polyline, bounds,
                markers, contentStrings, totExcitement){
            var finalPos=0;
            var nSections=0;
            var numSegmentsSec=0;
            for (i=0;i<legs.length;i++) {
                var steps = legs[i].steps;
                for (j=0;j<steps.length;j++) {
                    var nextSegment = steps[j].path;
                    var heading =0;
                    var TotSeclength =0;
                    var HeadVar =0;
                    var StartPoint = nextSegment[0];
                    var prevHeading =256;
                    var segLength =0;

                    for (k=0;k<nextSegment.length;k++) {
                        if(k>=1) segLength = google.maps.geometry.spherical.computeDistanceBetween(nextSegment[k-1], nextSegment[k]);
                        TotSeclength+=segLength;
                        polyline[nSections].getPath().push(nextSegment[k]);
                        bounds.extend(nextSegment[k]);
                        numSegmentsSec++;
                        finalPos = nextSegment[k];
                        //don't add the final marker
                        if(TotSeclength>= 5000){ 
                            markers[nSections] = new google.maps.Marker({
                            position: finalPos,
                            map: map,
                            });
                            totExcitement[nSections]= numSegmentsSec;
                            contentStrings[nSections] = '<div id="content">'+'Section='+nSections+'TotLenght='+TotSeclength.toFixed(2)+'Mark='+numSegmentsSec+'%'+'</div>';
                            numSegmentsSec = 0; //reset number of segments
                            TotSeclength = 0;
                            nSections++;
                            ///create a new polyline////
                            polyline[nSections]= new google.maps.Polyline({
                                path: [],
                                strokeColor: '#00FF00',
                                strokeWeight: 3,
                                map: map
                            });
                            polyline[nSections].getPath().push(nextSegment[k]);
                            //init new polyline where the previous ended.

                        }
                    }
                    
                }
            }
            return finalPos;
        }
        </script>

        <style type="text/css">
            html { height: 100% }
            body { height: 100%; margin: 0px; padding: 0px }
            #map_canvas { height: 100% }
        </style>
    </head>
    <body onload="initialize()">
      <div id="panel">
       <!-- <input id="address0" type="textbox" value="Al. Marszałka Józefa Piłsudskiego 50 Marki, Poland">
        <input id="address1" type="textbox" value="Al. Marszałka Józefa
        Piłsudskiego 24 Marki, Poland">-->
       <input id="address0" type="textbox" value="49.422011, 20.344653">
           <!-- "Pod Skałką 15 34-443 Sromowce Wyżne, Poland"> -->
        <input id="address1" type="textbox" value="49.434514, 20.346163"> 

        <select id="algorythm">
            <option value="0">Alg-1</option>
            <option value="1">Alg-2</option>
            <option value="2">Alg-3</option>
        </select>
        <input type="button" value="Evaluate" onclick="evaluatePath()">
        <input type="button" value="Reset" onclick="initialize()">
      </div> 	
	<div id="legend">
	   lookup route!
	</div>
  		<div id="map_canvas"></div>
      <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
      </script>
      <script type="text/javascript">
      _uacct = "UA-162157-1";
      urchinTracker();
      </script>	
      <script type="text/javascript">
        google.load('visualization', '1', {packages: ['corechart','bar']});
        function drawChart() {
                // Set chart options
                var options = {'title':'Motivation',
                    'width':400,'height':300, 'backgroundColor':
                    {fill:'transparent' }};
                var chart = new google.visualization.ColumnChart(document.getElementById('chart_div'));
                chart.draw(data, options);
        }
      </script>
      <div id="chart_div" style="position: absolute; z-index: 10;
          top:600px; left:1300px;"><div>
	</body>
</html>

